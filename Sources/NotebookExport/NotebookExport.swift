import Foundation
import Path

public struct NotebookExport {
    let filepath: Path
    
    public enum NotebookExportError: Error {
        case unexpectedNotebookFormat
    }
    
    let exportRegexp = NSRegularExpression(#"^\s*//\s*export\s*$"#)         // Swift 5 raw String
    
    /// Parse the notebook and extract the source of the exportable cells (minus the comment line)
    func extractExportableSources() throws -> [[String]] {
        let data = try Data(contentsOf: filepath)
        let json = try JSONSerialization.jsonObject(with: data, options: [])
        
        guard let jsonDictionary = json as? [String: Any] else {
            //TODO: Accept the payload if it's an array with a single dictionary inside
            throw NotebookExportError.unexpectedNotebookFormat
        }
        
        guard let cells = jsonDictionary["cells"] as? [[String: Any]] else {
            throw NotebookExportError.unexpectedNotebookFormat
        }
        
        // Use compactMap to combine the filter and map we need
        let exportableSources: [[String]] = cells.compactMap { cell in
            //TODO: Extract %install cells to auto-generate dependencies
            guard let source = cell["source"] as? [String] else { return nil }
            guard exportRegexp.matches(source.first) else { return nil }
            return Array(source[1...])
        }
        
        return exportableSources
    }
    
    /// Update global Package.swift
    func updatePackageSpec(at path: Path, packageName: String) throws {
        //FIXME: derive dependencies from sources

        // It would be nice if we could use PackageDescription to define the package and export the manifest
        let manifest = """
        // swift-tools-version:4.2
        import PackageDescription

        let package = Package(
            name: "\(packageName)",
            products: [
                .library(name: "\(packageName)", targets: ["\(packageName)"]),
            ],
        dependencies: [
            .package(url: "https://github.com/mxcl/Path.swift", from: "0.16.1"),
            .package(url: "https://github.com/JustHTTP/Just", from: "0.7.1")
        ],
        targets: [
            .target(
                name: "\(packageName)",
                dependencies: ["Just", "Path"]),
            ]
        )
        """
        try manifest.write(to: path/"Package.swift")
    }
}

// Public API
public extension NotebookExport {
    // Using different names than the Python version to avoid conflicts for now
    static let defaultPackagePath = "ExportedNotebooks"
    static let defaultPackagePrefix = "ExportedNotebook_"
    
    enum ExportResult {
        case success
        case failure(reason: String)
    }
    
    /// Export as an additional source inside the specified package path
    @discardableResult
    func toScript(inside packagePath: String = defaultPackagePath) -> ExportResult {
        let path = Path(packagePath) ?? Path.cwd/packagePath
        let newname = filepath.basename(dropExtension: true) + ".swift"
        let packageName = path.basename()
        let destination = path/"Sources"/packageName/newname
        do {
            var module = """
            /*
            THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
            file to edit: \(filepath.basename())
            
            */
            
            """
            for cellSource in try extractExportableSources() {
                module.append("\n" + cellSource.joined() + "\n")
            }

            try destination.parent.mkdir(.p)
            try module.write(to: destination, encoding: .utf8)
            try updatePackageSpec(at: path, packageName: packageName)
            return .success
        } catch {
            return .failure(reason: "Can't export \(filepath)")
        }
    }
    
    /// Export as an independent package prepending the specified prefix to the name
    @discardableResult
    func toPackage(prefix: String = defaultPackagePrefix) -> ExportResult {
        return .failure(reason: "Not implemented yet")
    }
    
    /// Perform both toScript() and toPackage()
    @discardableResult
    func export(inside packagePath: String = defaultPackagePath, independentPackagePrefix: String = defaultPackagePrefix) -> ExportResult {
        let firstResult = toScript(inside: packagePath)
        guard case .success = firstResult else { return firstResult }
        return toPackage(prefix: independentPackagePrefix)
    }

    init(_ filepath: Path) {
        self.filepath = filepath
    }
    
    init(_ filename: String) {
        self.init(Path(filename) ?? Path.cwd/filename)
    }

}
